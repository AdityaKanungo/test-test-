import pandas as pd
from collections import defaultdict

# -------------------------------------------------------------------
# Build relatives index: (referral_id, person_id) -> list of relative person_ids
# ONLY keep father/mother/guardian
# -------------------------------------------------------------------
def build_relatives_index_simple(df_rel):
    df_rel = df_rel.copy()
    df_rel["rel_type"] = df_rel["relative_relationship"].str.strip().str.lower()

    # Filter only desired relationships
    df_rel = df_rel[df_rel["rel_type"].isin(["father", "mother", "guardian"])]

    rel_index = defaultdict(list)

    for row in df_rel.itertuples(index=False):
        key = (str(row.referral_id), str(row.person_id))
        rel_index[key].append(str(row.relative_person_id))

    return rel_index


# -------------------------------------------------------------------
# Compare two lists of relative person_ids
# -------------------------------------------------------------------
def overlap_relative_ids(listA, listB):
    overlap = set(listA).intersection(set(listB))
    return len(overlap), sorted(list(overlap))


# -------------------------------------------------------------------
# MAIN PIPELINE
# -------------------------------------------------------------------
def confirm_likely_matches_by_relative_id(df_likely, df_rel):
    """
    df_rel must contain:
        referral_id, person_id, relative_person_id, relative_relationship

    df_likely must contain:
        referral_id, person_id,
        likely_matched_pair, likely_matched_person
    """

    # 1) Build index of only father/mother/guardian relatives
    rel_index = build_relatives_index_simple(df_rel)

    pair_records = []

    # 2) Loop through likely matches
    for idx, row in df_likely.iterrows():
        base_ref = str(row["referral_id"])
        base_person = str(row["person_id"])
        base_key = (base_ref, base_person)
        base_rels = rel_index.get(base_key, [])

        # Parse candidates
        cand_refs = str(row.get("likely_matched_pair", "")).split(",")
        cand_pers = str(row.get("likely_matched_person", "")).split(",")

        # Clean
        cand_refs = [c.strip() for c in cand_refs if c.strip()]
        cand_pers = [c.strip() for c in cand_pers if c.strip()]

        # Fix unequal lengths
        min_len = min(len(cand_refs), len(cand_pers))
        cand_refs = cand_refs[:min_len]
        cand_pers = cand_pers[:min_len]

        for c_ref, c_per in zip(cand_refs, cand_pers):
            cand_key = (str(c_ref), str(c_per))
            cand_rels = rel_index.get(cand_key, [])

            # SIMPLE MATCH â€” Shared relative_person_id
            num_matches, overlap_ids = overlap_relative_ids(base_rels, cand_rels)

            pair_records.append({
                "base_referral_id": base_ref,
                "base_person_id": base_person,
                "cand_referral_id": c_ref,
                "cand_person_id": c_per,
                "num_shared_relatives": num_matches,
                "shared_relative_ids": ",".join(overlap_ids),
                "confirmed_by_relatives": num_matches > 0
            })

    pair_df = pd.DataFrame(pair_records)

    # 3) Attach confirmed flag back onto df_likely
    df_likely = df_likely.copy()
    df_likely["confirmed_match_by_relatives"] = False

    for idx, row in df_likely.iterrows():
        ref = str(row["referral_id"])
        per = str(row["person_id"])

        # If ANY pair for this record is confirmed, mark True
        if not pair_df[
            (pair_df["base_referral_id"] == ref) &
            (pair_df["base_person_id"] == per) &
            (pair_df["confirmed_by_relatives"])
        ].empty:
            df_likely.at[idx, "confirmed_match_by_relatives"] = True

    return df_likely, pair_df
