Below is a **much simpler version** of your pipeline that **completely removes ALL FN/LN/DOB/SSN matching logic**.

### ✔️ New Logic

For each likely pair:

1. Get the list of relative **person_ids** for the BASE record.
2. Get the list of relative **person_ids** for the CANDIDATE record.
3. If **any relative_id matches**, we mark the likely pair as **confirmed_by_relatives = True**.

That’s it—no name, DOB, SSN, relationship logic.

---

# ✅ **Simplified Code — Relative Person ID Matching Only**

```python
import pandas as pd
from collections import defaultdict

# -------------------------------------------------------------------
# Build relatives index: (referral_id, person_id) -> list of relative person_ids
# -------------------------------------------------------------------
def build_relatives_index_simple(df_rel):
    """
    df_rel expected columns:
        referral_id, person_id,
        relative_person_id  <-- THIS must exist
    """
    rel_index = defaultdict(list)

    for row in df_rel.itertuples(index=False):
        key = (str(row.referral_id), str(row.person_id))
        rel_index[key].append(str(row.relative_person_id))

    return rel_index


# -------------------------------------------------------------------
# Compare two relative sets by PERSON ID only
# -------------------------------------------------------------------
def simple_relative_overlap(relA, relB):
    """
    Just checks if any relative_person_id exists in both lists.
    """
    setA = set(relA)
    setB = set(relB)
    overlap = setA.intersection(setB)
    return len(overlap), list(overlap)


# -------------------------------------------------------------------
# MAIN PIPELINE – simplified
# -------------------------------------------------------------------
def confirm_likely_matches_by_relative_id(df_likely, df_rel):
    """
    df_rel must have: referral_id, person_id, relative_person_id
    df_likely must have: referral_id, person_id,
                         likely_matched_pair, likely_matched_person
    """

    # 1) Build simple index of relatives
    rel_index = build_relatives_index_simple(df_rel)

    # 2) Store pair-level result
    pair_records = []

    for idx, row in df_likely.iterrows():
        base_ref = str(row["referral_id"])
        base_person = str(row["person_id"])
        base_key = (base_ref, base_person)
        rels_base = rel_index.get(base_key, [])

        # Parse candidates
        cand_refs_raw = str(row.get("likely_matched_pair", "")).strip()
        cand_pers_raw = str(row.get("likely_matched_person", "")).strip()

        if not cand_refs_raw or not cand_pers_raw:
            continue

        cand_ref_list = [c.strip() for c in cand_refs_raw.split(",") if c.strip()]
        cand_per_list = [c.strip() for c in cand_pers_raw.split(",") if c.strip()]

        # fix unequal lengths
        if len(cand_ref_list) != len(cand_per_list):
            min_len = min(len(cand_ref_list), len(cand_per_list))
            cand_ref_list = cand_ref_list[:min_len]
            cand_per_list = cand_per_list[:min_len]

        # Compare base vs each candidate
        for c_ref, c_per in zip(cand_ref_list, cand_per_list):
            cand_key = (str(c_ref), str(c_per))
            rels_cand = rel_index.get(cand_key, [])

            # SIMPLE MATCH: shared relative person_ids
            num_matches, overlap_ids = simple_relative_overlap(rels_base, rels_cand)

            pair_records.append({
                "base_referral_id": base_ref,
                "base_person_id": base_person,
                "cand_referral_id": c_ref,
                "cand_person_id": c_per,
                "num_relatives_matched": num_matches,
                "overlapping_relative_ids": ",".join(overlap_ids),
                "confirmed_by_relatives": num_matches > 0
            })

    pair_df = pd.DataFrame(pair_records)

    # 3) Attach confirmed flag back to df_likely
    df_likely = df_likely.copy()
    confirm_flags = []

    for idx, row in df_likely.iterrows():
        k_ref = str(row["referral_id"])
        k_per = str(row["person_id"])

        # If ANY pair for this (ref, person) was confirmed
        confirmed_any = (
            not pair_df[
                (pair_df["base_referral_id"] == k_ref) &
                (pair_df["base_person_id"] == k_per) &
                (pair_df["confirmed_by_relatives"])
            ].empty
        )

        confirm_flags.append(confirmed_any)

    df_likely["confirmed_match_by_relatives"] = confirm_flags

    return df_likely, pair_df
```

---

# ✅ **What This Version Does NOT Do**

❌ No FN/LN comparison
❌ No DOB matching
❌ No DOB estimated logic
❌ No SSN checks
❌ No relatives relationship matching
❌ No disjoint-set grouping

# ✔️ What It Now DOES

✔ Matches likely pairs **ONLY** when:
**A relative in BASE has the same person_id as a relative in CANDIDATE.**

This is the simplest possible version of “confirm likely match using relatives.”

---

# If you want even lighter logic

I can make it **one-liner match**, or remove the intermediate pair_df, or merge logic into df_likely directly.

Just tell me.
