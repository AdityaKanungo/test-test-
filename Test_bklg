
Short answer to your earlier question first:
2024-01-22 â†’ 2025-09-30 is 617 days (I miscounted by 1 before ðŸ’€).

Now, hereâ€™s complete Python code to compute:

1. Core descriptive stats for survival analysis


2. Observation window / follow-up distributions
â€“ separately for with CPS event and without CPS (censored)


3. KM survival probabilities at key time points


4. Optional: plots (KM curve, histograms)



Iâ€™ll assume your dataframe looks like this:

df[time_col] = number of days from index GPS to either first CPS or censor date

df[event_col] = 1 if CPS occurred, 0 if no CPS within observation window


You can rename whatever you have (time_since_index, days_to_cps_or_censor, etc.) to match.


---

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from lifelines import KaplanMeierFitter, NelsonAalenFitter

# ---------------------------------------------------------
# Helper: summarize a numeric Series
# ---------------------------------------------------------
def summarize_series(s: pd.Series) -> pd.Series:
    """
    Returns basic descriptive stats for a numeric pandas Series.
    Skips NA values.
    """
    s = s.dropna()
    if s.empty:
        return pd.Series(dtype="float64")

    summary = {
        "n": len(s),
        "mean": s.mean(),
        "std": s.std(),
        "min": s.min(),
        "q25": s.quantile(0.25),
        "median": s.median(),
        "q75": s.quantile(0.75),
        "max": s.max(),
    }
    return pd.Series(summary)


# ---------------------------------------------------------
# Main: compute descriptive stats for survival analysis
# ---------------------------------------------------------
def describe_survival(
    df: pd.DataFrame,
    time_col: str,
    event_col: str,
    key_times=(30, 90, 180, 365, 730),
    followup_bins=(0, 90, 180, 365, 730, np.inf),
    followup_labels=("0â€“<90", "90â€“<180", "180â€“<365", "365â€“<730", "730+"),
):
    """
    Compute core descriptive statistics for a survival dataset.

    Parameters
    ----------
    df : DataFrame
        Long-format dataset, one row per individual (or per index referral).
    time_col : str
        Column name with duration from index to CPS or censor (in days).
    event_col : str
        Column name with event indicator (1 = CPS event, 0 = censored).
    key_times : iterable
        Time points (in days) for which to report survival probabilities.
    followup_bins : iterable
        Bin edges for follow-up distributions, in days.
    followup_labels : iterable
        Labels for those bins.

    Returns
    -------
    results : dict
        Dictionary with all descriptive results.
    """

    df = df.copy()

    # Basic integrity checks
    if not set(df[event_col].dropna().unique()).issubset({0, 1}):
        raise ValueError(f"{event_col} must contain only 0/1 values for censor/event.")

    # ---------------------------------------------------------------------
    # 1. Core counts
    # ---------------------------------------------------------------------
    n_total = len(df)
    n_events = int(df[event_col].sum())
    n_censored = n_total - n_events

    core_counts = {
        "n_total": n_total,
        "n_events": n_events,
        "n_censored": n_censored,
        "event_rate_pct": 100 * n_events / n_total if n_total > 0 else np.nan,
        "censor_rate_pct": 100 * n_censored / n_total if n_total > 0 else np.nan,
    }

    # Split into events vs censored
    df_events = df[df[event_col] == 1]
    df_cens = df[df[event_col] == 0]

    # ---------------------------------------------------------------------
    # 2. Time-to-event stats (for those with CPS)
    # ---------------------------------------------------------------------
    event_time_summary = summarize_series(df_events[time_col])

    # ---------------------------------------------------------------------
    # 3. Follow-up / time-to-censor stats (for those without CPS)
    # ---------------------------------------------------------------------
    censor_time_summary = summarize_series(df_cens[time_col])

    # ---------------------------------------------------------------------
    # 4. Kaplanâ€“Meier survival curve + survival at key times
    # ---------------------------------------------------------------------
    kmf = KaplanMeierFitter()
    kmf.fit(durations=df[time_col], event_observed=df[event_col], label="Overall")

    survival_at_times = {}
    for t in key_times:
        survival_at_times[t] = float(kmf.predict(t))

    # Median survival time (can be inf if survival never drops below 0.5)
    median_survival_time = float(kmf.median_survival_time_)

    # ---------------------------------------------------------------------
    # 5. Cumulative hazard (Nelsonâ€“Aalen) â€“ for hazard shape summary
    # ---------------------------------------------------------------------
    naf = NelsonAalenFitter()
    naf.fit(durations=df[time_col], event_observed=df[event_col], label="Overall")

    # ---------------------------------------------------------------------
    # 6. Observation window distribution: follow-up bins
    #    (separate for events vs censored)
    # ---------------------------------------------------------------------
    # For those with CPS (time until event)
    if not df_events.empty:
        event_bins = pd.cut(
            df_events[time_col],
            bins=followup_bins,
            labels=followup_labels,
            right=False,  # [low, high)
        )
        event_bin_counts = event_bins.value_counts().sort_index()
        event_bin_props = (event_bin_counts / event_bin_counts.sum()).round(3)
        event_followup_dist = pd.DataFrame(
            {"count": event_bin_counts, "proportion": event_bin_props}
        )
    else:
        event_followup_dist = pd.DataFrame(columns=["count", "proportion"])

    # For censored (time of observation end)
    if not df_cens.empty:
        cens_bins = pd.cut(
            df_cens[time_col],
            bins=followup_bins,
            labels=followup_labels,
            right=False,
        )
        cens_bin_counts = cens_bins.value_counts().sort_index()
        cens_bin_props = (cens_bin_counts / cens_bin_counts.sum()).round(3)
        censor_followup_dist = pd.DataFrame(
            {"count": cens_bin_counts, "proportion": cens_bin_props}
        )
    else:
        censor_followup_dist = pd.DataFrame(columns=["count", "proportion"])

    # ---------------------------------------------------------------------
    # Collect all results
    # ---------------------------------------------------------------------
    results = {
        "core_counts": core_counts,
        "event_time_summary": event_time_summary,
        "censor_time_summary": censor_time_summary,
        "survival_at_times": survival_at_times,
        "median_survival_time": median_survival_time,
        "kmf": kmf,  # for plotting
        "naf": naf,  # for plotting hazard
        "event_followup_distribution": event_followup_dist,
        "censor_followup_distribution": censor_followup_dist,
    }

    return results


# ---------------------------------------------------------
# Optional: plotting helpers
# ---------------------------------------------------------
def plot_km(kmf):
    """
    Plot Kaplanâ€“Meier survival curve.
    """
    plt.figure()
    kmf.plot_survival_function()
    plt.title("Kaplanâ€“Meier Survival Curve")
    plt.xlabel("Days since index")
    plt.ylabel("Survival probability (no CPS yet)")
    plt.grid(True)
    plt.show()


def plot_cumulative_hazard(naf):
    """
    Plot cumulative hazard curve.
    """
    plt.figure()
    naf.plot_cumulative_hazard()
    plt.title("Cumulative Hazard (Nelsonâ€“Aalen)")
    plt.xlabel("Days since index")
    plt.ylabel("Cumulative hazard")
    plt.grid(True)
    plt.show()


def plot_followup_histograms(df, time_col, event_col):
    """
    Side-by-side histograms for:
      - time to CPS (events)
      - follow-up duration for censored (no CPS)
    """
    df_events = df[df[event_col] == 1]
    df_cens = df[df[event_col] == 0]

    plt.figure(figsize=(12, 5))

    # Events
    plt.subplot(1, 2, 1)
    plt.hist(df_events[time_col].dropna(), bins=30)
    plt.title("Time to CPS (events only)")
    plt.xlabel("Days since index")
    plt.ylabel("Count")

    # Censored
    plt.subplot(1, 2, 2)
    plt.hist(df_cens[time_col].dropna(), bins=30)
    plt.title("Follow-up time (no CPS / censored)")
    plt.xlabel("Days since index")
    plt.ylabel("Count")

    plt.tight_layout()
    plt.show()


---

ðŸ”§ How to use with your CWIS data

Assume your survival dataset is in df_surv with:

df_surv["time_since_index_days"] = days from index GPS to CPS or censor

df_surv["event_cps"] = 1 if CPS happened, 0 if not


results = describe_survival(
    df_surv,
    time_col="time_since_index_days",
    event_col="event_cps",
)

# Look at core counts
print("Core counts:")
print(results["core_counts"])

print("\nTime-to-event summary (CPS only):")
print(results["event_time_summary"])

print("\nFollow-up (censored, no CPS) summary:")
print(results["censor_time_summary"])

print("\nSurvival probabilities at key times (days):")
print(results["survival_at_times"])

print("\nMedian survival time (days):")
print(results["median_survival_time"])

print("\nFollow-up distribution for events (time to CPS):")
print(results["event_followup_distribution"])

print("\nFollow-up distribution for censored (no CPS):")
print(results["censor_followup_distribution"])

Plots:

plot_km(results["kmf"])
plot_cumulative_hazard(results["naf"])
plot_followup_histograms(df_surv, time_col="time_since_index_days", event_col="event_cps")


---

If you paste a small sample of your actual column names (or the survival dataframe shape), I can tweak this to align exactly with your field names + how youâ€™re constructing time and event.
