Here’s an AWS version of the same RAG architecture, with the flow and a diagram you can reuse.


---

1. Azure → AWS Service Mapping

Actors & Security

Case Workers / Policy Professionals → Same (corporate users)

SiteMinder Authentication (OIDC, MFA) → SiteMinder (existing) federated into AWS Cognito / IAM Identity Center

Service Authentication (SPN/Key/Service Account) → IAM Roles, IAM Users, AWS Secrets Manager, KMS

Azure Firewall → AWS Network Firewall + Security Groups + NACLs


App / API Layer

Azure Web App → Amazon ECS Fargate or AWS App Runner (or Elastic Beanstalk)

SOA Gateway (Akana) → Amazon API Gateway (or keep Akana on EC2 if you must)

Azure Function (orchestrator) → AWS Lambda


AI & Data

Azure OpenAI Services → Amazon Bedrock (or SageMaker endpoint)

Azure File Share – policy documents for embeddings → Amazon S3 (raw policy docs)

(optional but recommended) Vector Index → Amazon OpenSearch Serverless (vector engine) or Amazon Aurora PostgreSQL with pgvector

Azure Data Lake Gen2 – Q&A pairs & feedback → S3 Data Lake (+ Glue catalog, Athena/Redshift for analytics)

Azure Storage Account for Splunk → CloudWatch Logs + Kinesis Data Firehose → Splunk



---

2. AWS Architecture Flow (step-by-step)

1. User access & auth

Case worker browses to intranet Policy Engine URL.

SiteMinder authenticates user with MFA and issues OIDC/SAML token.

User is federated into Amazon Cognito (or IAM Identity Center) and receives app session.



2. Frontend web app

Browser connects (via internal load balancer) to ECS Fargate / App Runner hosting the Policy Engine UI within a VPC.

App uses Cognito tokens for user context and authorization.



3. API gateway / service layer

Frontend calls internal Amazon API Gateway endpoint.

API Gateway:

Verifies JWT (Cognito) / mTLS.

Routes request to AWS Lambda orchestrator.




4. RAG orchestration (Lambda)

Lambda validates the request and user permissions.

Lambda performs retrieval:

1. Uses metadata (policy type, business area, etc.) to search Amazon OpenSearch Serverless (vector index) or Aurora pgvector.


2. Vector index points to source documents in S3 holding the policy PDFs/Word docs.



Lambda fetches top-K relevant chunks from S3 (or from the vector index result payload).



5. LLM call

Lambda calls Amazon Bedrock (e.g., Claude, Titan, etc.) with:

System prompt (governance, tone, disclaimers).

Retrieved context snippets.

User question.


Bedrock returns the grounded answer plus optional citations.



6. Response logging & analytics

Lambda writes:

Question, retrieved doc IDs, model response.

User feedback (thumbs-up/down, comments).


These are stored in a S3 data lake partitioned by date/app/team.

Optional: also write to DynamoDB for low-latency per-conversation history.



7. Monitoring & Splunk

Lambda, ECS, API Gateway, and VPC logs → CloudWatch Logs.

A Kinesis Data Firehose stream ships relevant logs/metrics to Splunk.

Alarms and dashboards are set up in CloudWatch.



8. Network & security

All services run in private subnets, with:

VPC endpoints for S3, Bedrock, OpenSearch.

AWS Network Firewall + security groups restricting traffic.


Secrets (DB creds, API keys) in AWS Secrets Manager, encrypted with KMS.





---

3. Text Diagram (Mermaid)

You can paste this into any Mermaid-enabled tool (like many wiki systems) to render the diagram:

flowchart LR
    subgraph Users["Case Workers / Policy Professionals"]
        U[User Browser]
    end

    subgraph Auth["Identity & Access"]
        SM[SiteMinder<br/>OIDC + MFA]
        CG[Cognito / IAM Identity Center]
    end

    subgraph App["Application Layer (VPC)"]
        FE[ECS Fargate / App Runner<br/>Policy Engine Web App]
        APIGW[Amazon API Gateway]
        L[Lambda<br/>RAG Orchestrator]
    end

    subgraph DataAI["Data & AI"]
        S3Docs[(S3 - Policy Documents)]
        VectorDB[(OpenSearch Serverless<br/>or Aurora pgvector)]
        Bedrock[(Amazon Bedrock<br/>LLM)]
        S3Lake[(S3 Data Lake<br/>Q&A + Feedback)]
    end

    subgraph Observability["Logging & Monitoring"]
        CW[CloudWatch Logs & Metrics]
        FH[Kinesis Data Firehose]
        SPL[Splunk]
    end

    U -->|Intranet URL| SM --> CG --> FE
    FE -->|HTTPS / JWT| APIGW --> L

    L -->|Vector Search| VectorDB
    VectorDB -->|Doc IDs & Chunks| S3Docs
    L -->|Prompt + Context| Bedrock -->|Grounded Answer| L

    L -->|Store Q&A, Feedback| S3Lake

    FE -->|App Logs| CW
    L -->|Function Logs| CW
    APIGW -->|Access Logs| CW

    CW --> FH --> SPL


---

If you’d like, I can also tweak this for specific AWS choices you already use (e.g., “must be EC2 only”, “we use Redshift instead of Athena”, “we have an existing Akana gateway we must keep”), and I’ll remap the flow accordingly.
