Below is a clear, scalable way to perform the 7 exact-match criteria in Python using pandas.
Your goal is to link referrals (i.e., group records belonging to the same person) based on combinations of FN, LN, DOB, SSN according to the match-rules shown in your table.


---

âœ… Step-by-step solution

We will:

1. Normalize key fields (lowercase names, strip whitespace, convert DOB to datetime, handle blank SSNs).


2. Create match-rule flags (FN_match, LN_match, DOB_match, SSN_match).


3. Compute a match key for each of the 7 criteria.


4. Assign a person group ID so all matched referrals are linked together.



This method works efficiently on ~336k rows.


---

âœ… 1. Preprocess the columns

import pandas as pd
import numpy as np

df = victim_table.copy()

# Standardize text fields
df["first_name"] = df["first_name"].str.strip().str.lower()
df["last_name"]  = df["last_name"].str.strip().str.lower()

# Convert DOB
df["date_of_birth"] = pd.to_datetime(df["date_of_birth"], errors="coerce")

# SSN: convert blanks/unknown to NaN
df["social_security_number"] = df["social_security_number"].replace(["", " ", "unknown"], np.nan)


---

âœ… 2. Create match flags

# These will be used to generate match groups
df["FN"]  = df["first_name"]
df["LN"]  = df["last_name"]
df["DOB"] = df["date_of_birth"]
df["SSN"] = df["social_security_number"]


---

âœ… 3. Apply the 7 matching criteria

Using your screenshot, the 7 exact-match rules are:

Rule #	FN	LN	DOB	SSN

0	Yes	Yes	Yes	Yes
1	Yes	Yes	Yes	Blank
2	Yes	Yes	No	Yes
3	Yes	No	Yes	Yes
4	No	Yes	Yes	Yes
5	No	Yes	Yes	Blank
6	Yes	No	Yes	Blank


We create keys for each rule.

# Rule 0: FN + LN + DOB + SSN
df["match_key_0"] = df.FN + "|" + df.LN + "|" + df.DOB.astype(str) + "|" + df.SSN.astype(str)

# Rule 1: FN + LN + DOB (SSN blank)
df["match_key_1"] = df.FN + "|" + df.LN + "|" + df.DOB.astype(str)

# Rule 2: FN + LN + SSN (DOB mismatch)
df["match_key_2"] = df.FN + "|" + df.LN + "|" + df.SSN.astype(str)

# Rule 3: FN + DOB + SSN
df["match_key_3"] = df.FN + "|" + df.DOB.astype(str) + "|" + df.SSN.astype(str)

# Rule 4: LN + DOB + SSN
df["match_key_4"] = df.LN + "|" + df.DOB.astype(str) + "|" + df.SSN.astype(str)

# Rule 5: LN + DOB (SSN blank)
df["match_key_5"] = df.LN + "|" + df.DOB.astype(str)

# Rule 6: FN + DOB (SSN blank)
df["match_key_6"] = df.FN + "|" + df.DOB.astype(str)


---

âœ… 4. Assign a Person_ID using union-find logic

This ensures that records matching under any of the 7 criteria are grouped into the same person.

# Start with unique ID per row
df["Person_ID"] = df.index.astype("int64")

# For each rule: group by match key â†’ assign smallest ID in that group
for k in range(7):
    key = f"match_key_{k}"
    # Compute the minimal index per group
    group_min = df.groupby(key)["Person_ID"].transform("min")
    df["Person_ID"] = df[["Person_ID", group_min]].min(axis=1)

This collapses all interconnected matches into unified person IDs.


---

âœ… 5. (Optional) Collapse Person_IDs again to final stable IDs

# Final grouping to ensure transitive closure
df["Person_ID"] = df.groupby("Person_ID").ngroup()


---

ðŸŽ‰ Final result

df["Person_ID"] links all referrals belonging to the same individual.

All 7 exact-match criteria are applied.

Matching works across all rows (336k).

Scalable & fast.



---

ðŸ“Œ If you want, I can also provide:

âœ… A function that encapsulates this logic
âœ… Visualization of how many matches fall in each rule
âœ… Faster version using categorical hashing
âœ… Code to merge connected groups using networkx for graph-based matching

Just tell me!



