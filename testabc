def is_blank(x):
    return (x is None) or (x == "") or (str(x).strip() == "")
def matches(r1, r2):
    fn1, ln1, dob1, ssn1 = r1
    fn2, ln2, dob2, ssn2 = r2

    # Exact match
    if (
        fn1 == fn2 and 
        ln1 == ln2 and 
        dob1 == dob2 and 
        ssn1 == ssn2
    ):
        return True

    # Required: SSN must match for ALL other rules
    if ssn1 != ssn2:
        return False

    # 7 strict rules (6 imperfect + 1 exact already handled)
    rules = [
        # Rule 1: FN Yes, LN Yes, DOB No, SSN Yes
        fn1 == fn2 and ln1 == ln2 and dob1 != dob2,

        # Rule 2: FN Yes, LN No, DOB Yes, SSN Yes
        fn1 == fn2 and ln1 != ln2 and dob1 == dob2,

        # Rule 3: FN No, LN Yes, DOB Yes, SSN Yes
        fn1 != fn2 and ln1 == ln2 and dob1 == dob2,

        # Rule 4: FN No, LN Yes, DOB Blank, SSN Yes
        fn1 != fn2 and ln1 == ln2 and is_blank(dob1),

        # Rule 5: FN No, LN No, DOB Yes, SSN Yes
        fn1 != fn2 and ln1 != ln2 and dob1 == dob2,

        # Rule 6: FN Yes, LN No, DOB Blank, SSN Yes
        fn1 == fn2 and ln1 != ln2 and is_blank(dob1)
    ]

    return any(rules)


import pandas as pd
import networkx as nx

def build_longitudinal_dataset(df):
    df = df.copy()
    df["LONG_PERSON_ID"] = None
    next_id = 1

    # Group by SSN (mandatory: SSN must match to match at all)
    ssn_groups = df.groupby("SSN")

    for ssn, group in ssn_groups:
        indices = list(group.index)

        # -----------------------------------------
        # CASE 1: Blank SSN → cannot match anyone
        # -----------------------------------------
        if is_blank(ssn):
            for idx in indices:
                df.loc[idx, "LONG_PERSON_ID"] = next_id
                next_id += 1
            continue

        # -----------------------------------------
        # CASE 2: SSN is valid → run match logic within block
        # -----------------------------------------
        G = nx.Graph()
        G.add_nodes_from(indices)

        for i in range(len(indices)):
            for j in range(i + 1, len(indices)):
                idx1 = indices[i]
                idx2 = indices[j]

                r1 = df.loc[idx1, ["FIRST_NAME", "LAST_NAME", "DOB", "SSN"]]
                r2 = df.loc[idx2, ["FIRST_NAME", "LAST_NAME", "DOB", "SSN"]]

                if matches(tuple(r1), tuple(r2)):
                    G.add_edge(idx1, idx2)

        # Connected components = unique people
        for component in nx.connected_components(G):
            for idx in component:
                df.loc[idx, "LONG_PERSON_ID"] = next_id
            next_id += 1

    return df


df_long = build_longitudinal_dataset(df)

df_long.to_csv("referrals_longitudinal.csv", index=False)
