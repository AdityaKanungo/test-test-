def is_blank(x):
    return (x is None) or (str(x).strip() == "")
def match_rule(r1, r2):
    fn1, ln1, dob1, ssn1 = r1
    fn2, ln2, dob2, ssn2 = r2

    # Rule 0: Exact match
    if fn1 == fn2 and ln1 == ln2 and dob1 == dob2 and ssn1 == ssn2:
        return 0

    # SSN must match in all other rules
    if ssn1 != ssn2:
        return None

    # Rule 1
    if fn1 == fn2 and ln1 == ln2 and dob1 != dob2:
        return 1
    
    # Rule 2
    if fn1 == fn2 and ln1 != ln2 and dob1 == dob2:
        return 2
    
    # Rule 3
    if fn1 != fn2 and ln1 == ln2 and dob1 == dob2:
        return 3
    
    # Rule 4
    if fn1 != fn2 and ln1 == ln2 and is_blank(dob1):
        return 4
    
    # Rule 5
    if fn1 != fn2 and ln1 != ln2 and dob1 == dob2:
        return 5
    
    # Rule 6
    if fn1 == fn2 and ln1 != ln2 and is_blank(dob1):
        return 6

    return None


import pandas as pd
import networkx as nx

def build_longitudinal_dataset(df):

    df = df.copy()
    df["LONG_PERSON_ID"] = None
    df["MATCH_EXPLANATIONS"] = [[] for _ in range(len(df))]
    next_id = 1

    ssn_groups = df.groupby("SSN")

    for ssn, group in ssn_groups:

        idxs = list(group.index)

        # Case: Blank SSN â†’ cannot match anyone
        if is_blank(ssn):
            for idx in idxs:
                df.loc[idx, "LONG_PERSON_ID"] = next_id
                next_id += 1
            continue

        # Build graph for this SSN group
        G = nx.Graph()
        G.add_nodes_from(idxs)

        # Compare records inside SSN block
        for i in range(len(idxs)):
            for j in range(i + 1, len(idxs)):

                idx1, idx2 = idxs[i], idxs[j]

                r1 = df.loc[idx1, ["FIRST_NAME","LAST_NAME","DOB","SSN"]]
                r2 = df.loc[idx2, ["FIRST_NAME","LAST_NAME","DOB","SSN"]]

                rule_used = match_rule(tuple(r1), tuple(r2))

                if rule_used is not None:

                    # Step 1: add edge to graph
                    G.add_edge(idx1, idx2)

                    # Step 2: store explanation
                    df.at[idx1, "MATCH_EXPLANATIONS"].append({
                        "matched_with": int(idx2),
                        "rule_used": int(rule_used)
                    })
                    df.at[idx2, "MATCH_EXPLANATIONS"].append({
                        "matched_with": int(idx1),
                        "rule_used": int(rule_used)
                    })

        # Assign longitudinal IDs for each connected component
        for component in nx.connected_components(G):
            for idx in component:
                df.loc[idx, "LONG_PERSON_ID"] = next_id
            next_id += 1
    
    return df
