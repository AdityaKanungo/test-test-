import pandas as pd
import networkx as nx


def is_blank(x):
    return (x is None) or (str(x).strip() == "")


# ----------------------------------------------------------
# Exact + Strong Match Rules (0–6)
# ----------------------------------------------------------
def match_rule(r1, r2):
    fn1, ln1, dob1, ssn1 = r1
    fn2, ln2, dob2, ssn2 = r2

    # Rule 0: Exact match
    if fn1 == fn2 and ln1 == ln2 and dob1 == dob2 and ssn1 == ssn2:
        return 0

    # SSN must match for all other strong rules
    if ssn1 != ssn2:
        return None

    if fn1 == fn2 and ln1 == ln2 and dob1 != dob2:
        return 1
    
    if fn1 == fn2 and ln1 != ln2 and dob1 == dob2:
        return 2
    
    if fn1 != fn2 and ln1 == ln2 and dob1 == dob2:
        return 3
    
    if fn1 != fn2 and ln1 == ln2 and is_blank(dob1):
        return 4
    
    if fn1 != fn2 and ln1 != ln2 and dob1 == dob2:
        return 5
    
    if fn1 == fn2 and ln1 != ln2 and is_blank(dob1):
        return 6

    return None


# ----------------------------------------------------------
# Likely Match Rules (L1–L6)
# ----------------------------------------------------------
def likely_match_rule(r1, r2):
    fn1, ln1, dob1, ssn1 = r1
    fn2, ln2, dob2, ssn2 = r2

    if fn1 != fn2 and ln1 == ln2 and dob1 != dob2 and ssn1 == ssn2:
        return "L1"

    if fn1 == fn2 and ln1 != ln2 and dob1 != dob2 and ssn1 == ssn2:
        return "L2"

    if fn1 == fn2 and ln1 != ln2 and dob1 == dob2 and is_blank(ssn1) and is_blank(ssn2):
        return "L3"

    if fn1 != fn2 and ln1 == ln2 and dob1 == dob2 and is_blank(ssn1) and is_blank(ssn2):
        return "L4"

    if fn1 != fn2 and ln1 == ln2 and dob1 != dob2 and is_blank(ssn1) and is_blank(ssn2):
        return "L5"

    if fn1 == fn2 and ln1 == ln2 and dob1 == dob2 and is_blank(ssn1) and is_blank(ssn2):
        return "L6"

    return None


# ----------------------------------------------------------
# FULL Longitudinal Builder (with 4 flat output columns)
# ----------------------------------------------------------
def build_longitudinal_dataset(df):

    df = df.copy()

    df["LONG_PERSON_ID"] = None

    df["matched_pair"] = ""
    df["matched_rule"] = ""
    df["likely_matched_pair"] = ""
    df["likely_matched_rule"] = ""

    next_id = 1

    ssn_groups = df.groupby("SSN")

    for ssn, group in ssn_groups:
        idxs = list(group.index)

        if is_blank(ssn):
            for idx in idxs:
                df.loc[idx, "LONG_PERSON_ID"] = next_id
                next_id += 1
            continue

        G = nx.Graph()
        G.add_nodes_from(idxs)

        for i in range(len(idxs)):
            for j in range(i + 1, len(idxs)):

                idx1, idx2 = idxs[i], idxs[j]

                r1 = df.loc[idx1, ["FIRST_NAME", "LAST_NAME", "DOB", "SSN"]]
                r2 = df.loc[idx2, ["FIRST_NAME", "LAST_NAME", "DOB", "SSN"]]

                tup1, tup2 = tuple(r1), tuple(r2)

                rule_used = match_rule(tup1, tup2)

                if rule_used is not None:

                    # Add to component graph
                    G.add_edge(idx1, idx2)

                    # Append matched pair
                    df.at[idx1, "matched_pair"] += f"{idx2},"
                    df.at[idx2, "matched_pair"] += f"{idx1},"

                    # Append matched rule
                    df.at[idx1, "matched_rule"] += f"{rule_used},"
                    df.at[idx2, "matched_rule"] += f"{rule_used},"

                else:
                    likely_used = likely_match_rule(tup1, tup2)
                    if likely_used is not None:

                        df.at[idx1, "likely_matched_pair"] += f"{idx2},"
                        df.at[idx2, "likely_matched_pair"] += f"{idx1},"

                        df.at[idx1, "likely_matched_rule"] += f"{likely_used},"
                        df.at[idx2, "likely_matched_rule"] += f"{likely_used},"

        # Assign longitudinal IDs after strong matches
        for component in nx.connected_components(G):
            for idx in component:
                df.loc[idx, "LONG_PERSON_ID"] = next_id
            next_id += 1

    # Remove trailing commas
    for col in ["matched_pair", "matched_rule", "likely_matched_pair", "likely_matched_rule"]:
        df[col] = df[col].str.rstrip(",")

    return df
