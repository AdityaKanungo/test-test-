import pandas as pd
import networkx as nx


# ----------------------------------------------------------
# Helper: check blank DOB/SSN conditions
# ----------------------------------------------------------
def is_blank(x):
    return (x is None) or (str(x).strip() == "")


# ----------------------------------------------------------
# Exact + Strong Match Rules (0–6)
# ----------------------------------------------------------
def match_rule(r1, r2):
    fn1, ln1, dob1, ssn1 = r1
    fn2, ln2, dob2, ssn2 = r2

    # Rule 0: Exact match
    if fn1 == fn2 and ln1 == ln2 and dob1 == dob2 and ssn1 == ssn2:
        return 0

    # SSN must match for all other strong rules
    if ssn1 != ssn2:
        return None

    # Rule 1: FN Yes, LN Yes, DOB No, SSN Yes
    if fn1 == fn2 and ln1 == ln2 and dob1 != dob2:
        return 1

    # Rule 2: FN Yes, LN No, DOB Yes, SSN Yes
    if fn1 == fn2 and ln1 != ln2 and dob1 == dob2:
        return 2

    # Rule 3: FN No, LN Yes, DOB Yes, SSN Yes
    if fn1 != fn2 and ln1 == ln2 and dob1 == dob2:
        return 3

    # Rule 4: FN No, LN Yes, DOB Blank, SSN Yes
    if fn1 != fn2 and ln1 == ln2 and is_blank(dob1):
        return 4

    # Rule 5: FN No, LN No, DOB Yes, SSN Yes
    if fn1 != fn2 and ln1 != ln2 and dob1 == dob2:
        return 5

    # Rule 6: FN Yes, LN No, DOB Blank, SSN Yes
    if fn1 == fn2 and ln1 != ln2 and is_blank(dob1):
        return 6

    return None


# ----------------------------------------------------------
# Likely Match Rules (L1–L6)
# ----------------------------------------------------------
def likely_match_rule(r1, r2):

    fn1, ln1, dob1, ssn1 = r1
    fn2, ln2, dob2, ssn2 = r2

    # L1: FN No, LN Yes, DOB No, SSN Yes
    if fn1 != fn2 and ln1 == ln2 and dob1 != dob2 and ssn1 == ssn2:
        return "L1"

    # L2: FN Yes, LN No, DOB No, SSN Yes
    if fn1 == fn2 and ln1 != ln2 and dob1 != dob2 and ssn1 == ssn2:
        return "L2"

    # L3: FN Yes, LN No, DOB Yes, SSN Blank
    if fn1 == fn2 and ln1 != ln2 and dob1 == dob2 and is_blank(ssn1) and is_blank(ssn2):
        return "L3"

    # L4: FN No, LN Yes, DOB Yes, SSN Blank
    if fn1 != fn2 and ln1 == ln2 and dob1 == dob2 and is_blank(ssn1) and is_blank(ssn2):
        return "L4"

    # L5: FN No, LN Yes, DOB No, SSN Blank
    if fn1 != fn2 and ln1 == ln2 and dob1 != dob2 and is_blank(ssn1) and is_blank(ssn2):
        return "L5"

    # L6: FN Yes, LN Yes, DOB Yes, SSN Blank
    if fn1 == fn2 and ln1 == ln2 and dob1 == dob2 and is_blank(ssn1) and is_blank(ssn2):
        return "L6"

    return None


# ----------------------------------------------------------
# FULL Longitudinal Builder with Likely Match Tracking
# ----------------------------------------------------------
def build_longitudinal_dataset(df):

    df = df.copy()

    df["LONG_PERSON_ID"] = None

    # store the explanations
    df["MATCH_EXPLANATIONS"] = [[] for _ in range(len(df))]
    df["LIKELY_MATCH_EXPLANATIONS"] = [[] for _ in range(len(df))]

    next_id = 1

    # Block by SSN (major performance optimization)
    ssn_groups = df.groupby("SSN")

    for ssn, group in ssn_groups:
        idxs = list(group.index)

        # Case 1: Blank SSN → treat each as its own person
        if is_blank(ssn):
            for idx in idxs:
                df.loc[idx, "LONG_PERSON_ID"] = next_id
                next_id += 1
            continue

        # Otherwise: work inside this SSN block
        G = nx.Graph()
        G.add_nodes_from(idxs)

        # Pairwise comparison inside SSN block
        for i in range(len(idxs)):
            for j in range(i + 1, len(idxs)):

                idx1, idx2 = idxs[i], idxs[j]

                r1 = df.loc[idx1, ["FIRST_NAME", "LAST_NAME", "DOB", "SSN"]]
                r2 = df.loc[idx2, ["FIRST_NAME", "LAST_NAME", "DOB", "SSN"]]

                tup1, tup2 = tuple(r1), tuple(r2)

                # -------------------------------------
                # Step 1: Strong / Exact match?
                # -------------------------------------
                rule_used = match_rule(tup1, tup2)

                if rule_used is not None:

                    # add to graph (these form longitudinal chains)
                    G.add_edge(idx1, idx2)

                    # store match explanation
                    df.at[idx1, "MATCH_EXPLANATIONS"].append({
                        "matched_with": int(idx2),
                        "rule_used": int(rule_used)
                    })
                    df.at[idx2, "MATCH_EXPLANATIONS"].append({
                        "matched_with": int(idx1),
                        "rule_used": int(rule_used)
                    })

                else:
                    # -------------------------------------
                    # Step 2: Not a strong match -> check likely match
                    # -------------------------------------
                    likely_used = likely_match_rule(tup1, tup2)

                    if likely_used is not None:
                        df.at[idx1, "LIKELY_MATCH_EXPLANATIONS"].append({
                            "matched_with": int(idx2),
                            "rule_used": likely_used
                        })
                        df.at[idx2, "LIKELY_MATCH_EXPLANATIONS"].append({
                            "matched_with": int(idx1),
                            "rule_used": likely_used
                        })

        # Assign Longitudinal IDs for strong-match components
        for component in nx.connected_components(G):
            for idx in component:
                df.loc[idx, "LONG_PERSON_ID"] = next_id
            next_id += 1

    return df
