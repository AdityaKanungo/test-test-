Below is the **fully updated, ready-to-paste code** with the correct DOB-EST logic applied everywhere:

‚úî DOB match only when BOTH DOB_EST = `"N"`
‚úî If either or both DOBs are estimated ‚Üí **DOB is not comparable**
‚úî In that case ‚Üí **dob_match = False** and **dob_ne_match = False**
‚úî Strong rules & likely rules updated
‚úî Main loop updated to pass DOB_EST into rule functions

---

# ‚úÖ **UPDATED FULL CODE (Strong + Likely rules + Main function)**

### üî• *You can paste this directly over your existing code.*

---

## ‚≠ê **1. Helper functions (unchanged)**

```python
def is_blank(x):
    import pandas as pd
    if pd.isna(x):
        return True
    if isinstance(x, str) and x.strip() == "":
        return True
    return False

def nonblank_equal(a, b):
    return (a == b) and (not is_blank(a)) and (not is_blank(b))

def nonblank_not_equal(a, b):
    return (a != b) and (not is_blank(a)) and (not is_blank(b))
```

---

## ‚≠ê **2. UPDATED Strong Match Rules (0‚Äì6)**

### üî• DOB_EST logic added at the top

```python
def match_rule(r1, r2):
    fn1, ln1, dob1, ssn1, dob_est1 = r1
    fn2, ln2, dob2, ssn2, dob_est2 = r2

    # ---------------------------
    # NEW DOB handling
    # ---------------------------
    dob1_blank = is_blank(dob1)
    dob2_blank = is_blank(dob2)

    dob1_est = (dob_est1 == "Y")
    dob2_est = (dob_est2 == "Y")

    # DOB comparable only when:
    # - not blank
    # - not estimated
    dob_comparable = (not dob1_blank) and (not dob2_blank) and (not dob1_est) and (not dob2_est)

    if dob_comparable:
        dob_match = (dob1 == dob2)
        dob_ne_match = (dob1 != dob2)
    else:
        dob_match = False
        dob_ne_match = False
    # ---------------------------

    # Rule 0: FN= LN= DOB= SSN=
    if nonblank_equal(fn1, fn2) and nonblank_equal(ln1, ln2) and dob_match and nonblank_equal(ssn1, ssn2):
        return 0

    # Rule 1: FN= LN= DOB‚â† SSN=
    if nonblank_equal(fn1, fn2) and nonblank_equal(ln1, ln2) and dob_ne_match and nonblank_equal(ssn1, ssn2):
        return 1

    # Rule 2: FN= LN‚â† DOB= SSN=
    if nonblank_equal(fn1, fn2) and nonblank_not_equal(ln1, ln2) and dob_match and nonblank_equal(ssn1, ssn2):
        return 2

    # Rule 3: FN‚â† LN= DOB= SSN=
    if nonblank_not_equal(fn1, fn2) and nonblank_equal(ln1, ln2) and dob_match and nonblank_equal(ssn1, ssn2):
        return 3

    # Rule 4: FN‚â† LN= DOB blank or not comparable, SSN=
    if nonblank_not_equal(fn1, fn2) and nonblank_equal(ln1, ln2) and (dob1_blank or dob2_blank or not dob_comparable) and nonblank_equal(ssn1, ssn2):
        return 4

    # Rule 5: FN‚â† LN‚â† DOB= SSN=
    if nonblank_not_equal(fn1, fn2) and nonblank_not_equal(ln1, ln2) and dob_match and nonblank_equal(ssn1, ssn2):
        return 5

    # Rule 6: FN= LN‚â† DOB blank or not comparable, SSN=
    if nonblank_equal(fn1, fn2) and nonblank_not_equal(ln1, ln2) and (dob1_blank or dob2_blank or not dob_comparable) and nonblank_equal(ssn1, ssn2):
        return 6

    return None
```

---

## ‚≠ê **3. UPDATED Likely Match Rules (7‚Äì12)**

### üî• Identical DOB_EST logic added here too

```python
def likely_match_rule(r1, r2):
    fn1, ln1, dob1, ssn1, dob_est1 = r1
    fn2, ln2, dob2, ssn2, dob_est2 = r2

    # ---------------------------
    # NEW DOB handling
    # ---------------------------
    dob1_blank = is_blank(dob1)
    dob2_blank = is_blank(dob2)

    dob1_est = (dob_est1 == "Y")
    dob2_est = (dob_est2 == "Y")

    dob_comparable = (not dob1_blank) and (not dob2_blank) and (not dob1_est) and (not dob2_est)

    if dob_comparable:
        dob_match = (dob1 == dob2)
        dob_ne_match = (dob1 != dob2)
    else:
        dob_match = False
        dob_ne_match = False
    # ---------------------------

    # #7: FN‚â† LN= DOB‚â† SSN=
    if nonblank_not_equal(fn1, fn2) and nonblank_equal(ln1, ln2) and dob_ne_match and nonblank_equal(ssn1, ssn2):
        return "7"

    # #8: FN= LN‚â† DOB‚â† SSN=
    if nonblank_equal(fn1, fn2) and nonblank_not_equal(ln1, ln2) and dob_ne_match and nonblank_equal(ssn1, ssn2):
        return "8"

    # #9: FN= LN‚â† DOB= SSN blank
    if nonblank_equal(fn1, fn2) and nonblank_not_equal(ln1, ln2) and dob_match and (is_blank(ssn1) or is_blank(ssn2)):
        return "9"

    # #10: FN‚â† LN= DOB= SSN blank
    if nonblank_not_equal(fn1, fn2) and nonblank_equal(ln1, ln2) and dob_match and (is_blank(ssn1) or is_blank(ssn2)):
        return "10"

    # #11: FN‚â† LN= DOB‚â† SSN blank
    if nonblank_not_equal(fn1, fn2) and nonblank_equal(ln1, ln2) and dob_ne_match and (is_blank(ssn1) or is_blank(ssn2)):
        return "11"

    # #12: FN= LN= DOB= SSN blank
    if nonblank_equal(fn1, fn2) and nonblank_equal(ln1, ln2) and dob_match and (is_blank(ssn1) or is_blank(ssn2)):
        return "12"

    return None
```

---

## ‚≠ê **4. UPDATED Main Function (Only the part where r1, r2 are built changes)**

### üî• Now passes DOB_EST into the rule functions

```python
# Strong matches
dsu = DisjointSet(n)
ssn_groups = defaultdict(list)

for i, ssn in enumerate(SSN):
    if not is_blank(ssn):
        ssn_groups[ssn].append(i)

for ssn, idxs in ssn_groups.items():
    if len(idxs) < 2:
        continue
    for i, j in combinations(idxs, 2):

        r1 = (FN[i], LN[i], DOB[i], SSN[i], DOB_EST[i])
        r2 = (FN[j], LN[j], DOB[j], SSN[j], DOB_EST[j])

        rule = match_rule(r1, r2)
        if rule is None:
            continue

        matched_pair[i] = f"{matched_pair[i]}{ref_ids[j]};"
        matched_rule[i] = f"{matched_rule[i]}{rule};"

        matched_pair[j] = f"{matched_pair[j]}{ref_ids[i]};"
        matched_rule[j] = f"{matched_rule[j]}{rule};"

        dsu.union(i, j)
```

---

## ‚≠ê **5. UPDATED Likely Matching Block**

### üî• Also passes DOB_EST

```python
blocks = [
    ["FN", "LN", "DOB"],
    ["FN", "LN"],
    ["FN", "DOB"],
    ["LN", "DOB"]
]

pairs_seen = set()

for cols in blocks:
    key_arrays = [df[c].to_numpy(object) for c in cols]
    groups = defaultdict(list)

    for i in range(n):
        key = tuple(arr[i] for arr in key_arrays)
        groups[key].append(i)

    for idxs in groups.values():
        if len(idxs) < 2:
            continue

        for i, j in combinations(idxs, 2):
            if i > j:
                i, j = j, i

            if (i, j) in pairs_seen:
                continue

            pairs_seen.add((i, j))

            r1 = (FN[i], LN[i], DOB[i], SSN[i], DOB_EST[i])
            r2 = (FN[j], LN[j], DOB[j], SSN[j], DOB_EST[j])

            rule = likely_match_rule(r1, r2)
            if rule is None:
                continue

            likely_pair[i] = f"{likely_pair[i]}{ref_ids[j]};"
            likely_rule[i] = f"{likely_rule[i]}{rule};"

            likely_pair[j] = f"{likely_pair[j]}{ref_ids[i]};"
            likely_rule[j] = f"{likely_rule[j]}{rule};"
```

---

# üéâ **DONE ‚Äî FULL CODE UPDATED EXACTLY TO YOUR SPECIFICATIONS**

This implementation ensures:

### ‚úî Estimated DOBs are **not treated as matches**

### ‚úî Estimated DOBs are **not treated as mismatches**

### ‚úî DOB becomes completely **non-comparable** when estimated

### ‚úî All strong rules (0‚Äì6) remain correct

### ‚úî All likely rules (7‚Äì12) remain correct

---

# If you want‚Ä¶

I can also give you:

‚úÖ Unit tests for each rule
‚úÖ Logging version (to see exactly why a rule fired)
‚úÖ A validation engine that prints ‚Äúwhy this was not a match‚Äù

Just tell me.

